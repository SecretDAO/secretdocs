---
description: >-
  An example of how to use Secret VRF to fetch random numbers via IBC between
  Secret and Juno testnet
---

# SecretVRF for IBC via proxy contracts

## Cross-chain random numbers demo

This documentation serves as a demo on how to send **cross-chain random numbers from Secret Network testnet to Juno testnet via IBC**. The demo repository [can be cloned here](https://github.com/scrtlabs/examples/tree/master/secret-ibc-rng-template).

The design system weâ€™ll be using consists of **one Secret contract and two Juno contracts**:

* **Secret Proxy Contract**: A Secret contract that requests a random number and specifies the callback information for the response.
* **Juno Proxy Contract**: A Juno contract that sends an IBC message to fetch the random number from the Secret Network proxy contract.
* **Juno Consumer Contract**: A Juno contract that consumes the random numbers generated by the Secret proxy contract.

{% hint style="info" %}
The Secret proxy contract will produce a _different, non-predictable_ number for each request it receives. You can read more about random numbers on Secret Network in the [technical specification of this feature.](../../secret-contract-fundamentals/secret-vrf-on-chain-randomness.md)
{% endhint %}

See here for a diagram of the system architecture:

<figure><img src="../../../.gitbook/assets/Blocks.png" alt=""><figcaption><p>Secret VRF IBC smart contract architecture</p></figcaption></figure>

### Environment Configuration

There are two steps to configuring your environment:

1. Upload and instantiate the three smart contracts
2. Configure an IBC relayer to properly relay packets between your chains of choice (for this demo we will use [Hermes](https://hermes.informal.systems/index.html)).

#### Upload and instantiate Secret Smart Contract

To begin, let's upload and instantiate the Secret Network proxy smart contract with Secret.js. [Clone the repository](https://github.com/scrtlabs/examples/tree/master/secret-ibc-rng-template):&#x20;

```bash
git clone https://github.com/scrtlabs/examples
```

then `cd` into `secret-ibc-rng-template/node:`

```bash
cd secret-ibc-rng-template/node
```

Run `npm i` to install the dependencies:

```bash
npm i 
```

Then, create a `.env` file and add your wallet mnemonic:

<figure><img src="../../../.gitbook/assets/env .png" alt=""><figcaption></figcaption></figure>

**Compile the contract:**

Open a new terminal window and `cd` into `secret-ibc-rng-template/proxy:`

```bash
cd secret-ibc-rng-template/proxy
```

Run the Makefile compile script:

```bash
make build-mainnet-reproducible
```

Then upload + instantiate the contract in `secret-ibc-rng-template/node:`

```bash
node upload_instantiate_secret_proxy
```

#### Upload and instantiate Juno Smart Contracts

Now that we have our Secret proxy contract, let's upload and instantiate the two Juno smart contracts.

{% hint style="info" %}
You can configure the consumer contracts for any IBC-compatible chain of your choosing. However, for this demo will be uploading and instantiating our contracts on Juno.
{% endhint %}

**Compile Juno Proxy Contract**

Open a new terminal window and `cd` into `secret-ibc-rng-template/consumer-side-proxy:`

```bash
cd secret-ibc-rng-template/consumer-side-proxy
```

Run the Makefile compile script:

```bash
make build-mainnet-reproducible
```

**Compile Juno Consumer Contract**

Open a new terminal window and `cd` into `secret-ibc-rng-template/consumer:`

```bash
cd secret-ibc-rng-template/consumer
```

Run the Makefile compile script:

```bash
make build-mainnet-reproducible
```

**Upload Juno Contracts**

Next, upload the compiled `wasm` files to Juno testnet using [Juno Tools](https://test.juno.tools/contracts/upload/), and be sure to note the respective `codeIds:`

<figure><img src="../../../.gitbook/assets/Screenshot 2024-01-08 at 3.24.27â€¯PM.png" alt="" width="375"><figcaption></figcaption></figure>

You should see the `transaction result` returned upon successful upload.&#x20;

#### Instantiate contracts

{% hint style="info" %}
If using the CLI, update to junod v16.0. If using js/ts, update [CosmJS to 0.31](https://github.com/scrtlabs/examples/blob/cfd1976e30cbe78a866386e27600526a5952add9/secret-ibc-rng-template/node/package.json#L14C37-L14C37).
{% endhint %}

{% hint style="info" %}
To upload the contracts to Juno testnet, you need Juno testnet tokens in your wallet. Visit faucet.reece.sh/uni-6/\<your Juno address> to receive testnet tokens
{% endhint %}

Next, instantiate the Juno proxy contract by running the following in your terminal:

{% code overflow="wrap" %}
```
junod tx wasm instantiate <your-code-id> '{}' --label 'juno-proxy' --no-admin --from <your-wallet> --gas 200000 -y --chain-id uni-6 --node https://rpc.uni.junonetwork.io:443 --gas-prices 0.025ujunox
```
{% endcode %}

Then, to query that the instantiation was successful and find the contract address, query the returned `txHash` with:

```
junod q tx <txHash> --node https://rpc.uni.junonetwork.io:443
```

You should see the `contract_address` variable:

{% code overflow="wrap" %}
```bash
juno1r9awn4hek5s8kuvfm46kh775csqvhuzs00j8c0djaul5729s48usht3j0s 
```
{% endcode %}

Now, simply repeat the process for the Juno Consumer contract. The only difference is that the instantiation message is slightly modified because it needs to include the other Juno `contract_address` that you instantiated as a pointer:

{% code overflow="wrap" %}
```markup
junod tx wasm instantiate <your code id> '{"init": {"rand_provider": { "address": <your juno contract address>, "code_hash": ""}}}' --label 'juno-consumer' --no-admin --from <your wallet name> --gas 300000 -y --chain-id uni-6 --node https://rpc.uni.junonetwork.io:443 --gas-prices 0.025ujunox
```
{% endcode %}

Query the returned `txHash:`

```
junod q tx <txHash> --node https://rpc.uni.junonetwork.io:443
```

You should see the `contract_address` variable:

{% code overflow="wrap" %}
```bash
juno1sznkzlleqlxw8lp8hy66l0zg0fe8khgkeyqlfmlvdkutgxjw69xq7jm32t
```
{% endcode %}

#### Configuring Hermes Relayer

Now that you have successfully uploaded and instantiated the three smart contracts, let's configure Hermes Relayer to relay packets between Secret test and Juno testnet.

First, [install Hermes and Gaiad manager](https://hermes.informal.systems/quick-start/index.html).

Then, configure Hermes by navigating to the folder `.hermes` and opening the `config.toml` file.

{% hint style="info" %}
If you're on a Mac, you may need to press `Command + Shift + Period` to see hidden files, such as the `.hermes` folder.
{% endhint %}

To relay packets between Secret Network testnet and Juno testnet, update the `config.toml` file with this configuration:

```toml
[global]
log_level = 'info'

[mode]

[mode.clients]
enabled = true
refresh = true
misbehaviour = true

[mode.connections]
enabled = true

[mode.channels]
enabled = true

[mode.packets]
enabled = true
clear_interval = 100
clear_on_start = true
tx_confirmation = true

[telemetry]
enabled = true
host = '127.0.0.1'
port = 3001

[[chains]]
id = 'pulsar-3'
type = 'CosmosSdk'
rpc_addr = 'https://rpc.pulsar.scrttestnet.com:443'
grpc_addr = 'http://grpcbin.pulsar.scrttestnet.com:9099'
event_source = { mode = 'push', url = 'wss://rpc.pulsar.scrttestnet.com:443/websocket', batch_delay = '500ms' }
rpc_timeout = '10s'
account_prefix = 'secret'
key_name = 'wallet'
store_prefix = 'ibc'
default_gas = 100000
max_gas = 400000
gas_multiplier = 1.1
max_msg_num = 30
max_tx_size = 180000
clock_drift = '5s'
max_block_time = '30s'
memo_prefix = ''
sequential_batch_tx = false
trusting_period = '16hrs'

[chains.trust_threshold]
numerator = '1'
denominator = '3'

[chains.gas_price]
price = 0.1
denom = 'uscrt'

[chains.packet_filter]
policy = 'allow'
list = [['wasm.*', '*'], ['transfer', '*']]

[[chains]]
id = 'uni-6'
rpc_addr = 'https://juno-testnet-rpc.polkachu.com:443'
grpc_addr = 'http://juno-testnet-grpc.polkachu.com:12690'
event_source = { mode = 'push', url = 'wss://juno-testnet-rpc.polkachu.com:443/websocket', batch_delay = '500ms' }
rpc_timeout = '10s'
account_prefix = 'juno'
key_name = 'wallet'
address_type = { derivation = 'cosmos' }
store_prefix = 'ibc'
default_gas = 1800000
max_gas = 9000000
gas_price = { price = 0.026, denom = 'ujunox' }
gas_multiplier = 1.2
max_msg_num = 30
max_tx_size = 179999
clock_drift = '15s'
max_block_time = '10s'
trusting_period = '448h'
memo_prefix = 'relayed by CryptoCrew Validators'
trust_threshold = { numerator = '1', denominator = '3' }

[chains.packet_filter]
policy = 'allow'
list = [['wasm.*', '*'], ['transfer', '*']]
```

Next, configure Gaiad Manager by navigating to the folder `.gm`, and then update the gm.toml file with the [configuration seen here.](https://github.com/scrtlabs/examples/blob/master/secret-ibc-rng-template/gm.toml)

{% hint style="info" %}
If you are using Hermes Relayer, make sure your paths are set up correctly in both the `config.toml and gm.toml`. See the image below for reference:
{% endhint %}

<figure><img src="../../../.gitbook/assets/path config.png" alt="" width="375"><figcaption><p>gm.toml configuration paths</p></figcaption></figure>

Now let's relay packets! ðŸŽ‰

### Consuming the random number via IBC

Now it's time to execute our IBC smart contracts and relay packets between Juno testnet and Secret testnet. If you run into any issues at this step, refer to the [hermes docs ](https://hermes.informal.systems/tutorials/local-chains/start-local-chains.html)for guidance, and also ask questions in the [Secret Network developer discord chat](https://discord.com/channels/360051864110235648/603225118545674241)!

1. Start Gaiad Manager

```
gm start
```

2. Add your Secret and Juno testnet wallets to Hermes:&#x20;

`cd` into `examples/secret-ibc-rng-template:`

```bash
cd examples/secret-ibc-rng-template
```

and update the `a.mnemonic` file to include your testnet wallet address like so:

```
your mnemonic wallet words to go here with no quotes
```

Then run the following to add your testnet wallet address to Hermes:&#x20;

{% code overflow="wrap" %}
```bash
hermes keys add --hd-path "m/44'/529'/0'/0/0" --mnemonic-file a.mnemonic --chain pulsar-3

hermes keys add --hd-path "m/44'/529'/0'/0/0" --mnemonic-file a.mnemonic --chain uni-6
```
{% endcode %}

{% hint style="info" %}
If you run into errors at this step, see the official Hermes docs for adding keys [here](https://hermes.informal.systems/documentation/commands/keys/index.html).&#x20;
{% endhint %}

3. Create clients

```bash
hermes create client --host-chain pulsar-3 --reference-chain uni-6
hermes create client --host-chain uni-6 --reference-chain pulsar-3
```

4. Create connections

{% code overflow="wrap" %}
```
hermes create connection --a-chain uni-6 --a-client 07-tendermint-468 --b-client 07-tendermint-235
```
{% endcode %}

{% hint style="info" %}
In place of `07-tendermint-235 and 07-tendermint-468`, use the client IDs returned to you in your terminal.
{% endhint %}

Upon success, you should see a message like so:

<figure><img src="../../../.gitbook/assets/hermes connection id.png" alt="" width="332"><figcaption></figcaption></figure>

Now that a channel is established, let's create a channel identifier, which links the Juno proxy contract to the Secret proxy contract. **Note that** **the ports listed below are the addresses of the Juno and Secret proxy contracts which we instantiated earlier.**

5. Create channel identifier

{% code overflow="wrap" %}
```bash
hermes create channel --a-chain uni-6 --a-connection connection-612 --a-port wasm.juno1ecl4r6dhhlluz56jqm24t6ss7s9gr6d0pu2lumvpwnnk56gnw7gqpz8m6c --b-port wasm.secret1rmccmgwf6zf2kawrv7h5faq3tx883epz7ty6tj
```
{% endcode %}

After successfully creating a channel identifier, we can relay packets! Let's start Hermes and then execute the Juno consumer contract to send a random network from Secret Network to Juno ðŸ¤¯

6. Start Hermes (open a new terminal window and then run the following)

```
hermes start 
```

{% hint style="info" %}
Hermes will scan the chain for all clients, connections and channels. This might take some time, which is normal. If you want to specify which channels it scans, update the hermes config file to include the following at the end of the chain configuration:
{% endhint %}

```
[chains.packet_filter]
policy = 'allow'
list = [
  ['transfer', 'channel-495'],
]
```

After Hermes has started running, execute the Juno consumer contract to return a random number from Secret via IBC:

{% code overflow="wrap" %}
```bash
junod tx wasm execute --from <your wallet name> juno1z4n39vfckeuv6udx6f4e6h8d5mt3xucuwdjs6lk2ets60ejruseqnpt00k '{"do_something": {}}' --gas 300000 -y --chain-id uni-6 --node https://rpc.uni.junonetwork.io:443 --gas-prices 0.025ujunox
```
{% endcode %}

Then, query the smart contract to see if it returned the random number:

{% code overflow="wrap" %}
```
junod query wasm contract-state smart <your-contract-address> '{"last_random": {}}' --chain-id uni-6 --node https://rpc.uni.junonetwork.io:443 
```
{% endcode %}

Upon successful execution, a random number will be returned:

<figure><img src="../../../.gitbook/assets/Screen Shot 2023-07-07 at 12.36.24 AM.png" alt="" width="357"><figcaption></figcaption></figure>

### Conclusion

Congrats! You now have the tools to implement cross-chain random number generation via IBC. By following these steps, you can facilitate and execute smart contracts and relay packets between Juno and Secret, as well as any other IBC-compatible chain, expanding the possibilities for blockchain interoperability and fostering new avenues for decentralized application development.

### Epilogue: IBC Fundamentals

If you are brand new to IBC, here is a quick crash course!

To connect two CosmWasm contracts over IBC you must establish an IBC channel between them. The IBC channel establishment process uses a four way handshake. Here is a summary of the steps:

1. `OpenInit` Hello chain B, here is information that you can use to verify I am chain A. Do you have information I can use?
2. `OpenTry` Hello chain A, I have verified that you are who you say you are. Here is my verification information.
3. `OpenAck` Hello chain B. Thank you for that information I have verified you are who you say you are. I am now ready to talk.
4. `OpenConfirm` Hello chain A. I am also now ready to talk.

Once the handshake has been completed a channel will be established that the ibc messages may be sent over. In order to do a handshake and receive IBC messages your contract must implement the following entry points (which are implemented in our proxy contract):

1. `ibc_channel_open` - Handles the `OpenInit` and `OpenTry` handshake steps.
2. `ibc_channel_connect` - Handles the `OpenAck` and `OpenConfirm` handshake steps.
3. `ibc_channel_close` - Handles the closing of an IBC channel by the counterparty.
4. `ibc_packet_receive` - Handles receiving IBC packets from the counter-party.
5. `ibc_packet_ack` - Handles ACK messages from the counter-party.
6. `ibc_packet_timeout` - Handles packet timeouts.

{% hint style="info" %}
[Here is a great repo](https://github.com/0xekez/cw-ibc-example) to learn more about IBC fundamentals [ðŸŽ‰](https://emojipedia.org/party-popper/)
{% endhint %}
